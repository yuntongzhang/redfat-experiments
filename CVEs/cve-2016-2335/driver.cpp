/**
 * g++ -std=c++11 -o driver -O2 driver.cpp
 * valgrind --undef-value-errors=no ./driver 20
 **/

#include <stdint.h>
#include <stdlib.h>
#include <vector>

struct CLogBlockAddr
{
  u_int32_t Pos;
  u_int16_t PartitionRef;
};

struct CLongAllocDesc
{
  u_int32_t Len;
  CLogBlockAddr Location;
};

struct CPartitionMap
{
  uint8_t Type;
  u_int16_t PartitionNumber;
  int PartitionIndex;
};

struct CPartition
{
  u_int16_t Number;
  uint32_t Pos;
  uint32_t Len;
};

struct CLogVol
{
  uint32_t BlockSize;
  std::vector<CPartitionMap> PartitionMaps;
};

class CInArchive
{
public:
    std::vector<CPartition> Partitions;
    std::vector<CLogVol> LogVols;
    int ReadFileItem(int volIndex, int fsIndex, const CLongAllocDesc &lad, int numRecurseAllowed);
};

int CInArchive::ReadFileItem(int volIndex, int fsIndex, const CLongAllocDesc &lad, int numRecurseAllowed)
{
  const CLogVol &vol = LogVols[volIndex];
  CPartition &partition = Partitions[vol.PartitionMaps[lad.Location.PartitionRef].PartitionIndex];
  if (&partition == nullptr)
    return 1;
  return 0;
}

// use 20 as arg
int main(int argc, char** argv)
{
    CInArchive cin;
    CLongAllocDesc *lad = (CLongAllocDesc *) malloc(sizeof(CLongAllocDesc));
    lad->Location.PartitionRef = atoi(argv[1]);
    
    CLogVol vol;
    CPartitionMap map1;
    CPartitionMap map2;
    vol.PartitionMaps.push_back(map1);
    vol.PartitionMaps.push_back(map2);
    cin.LogVols.push_back(vol);
    // alloc sth to skip valgrind detection
    CLogVol vol_one;
    vol_one.PartitionMaps.push_back(map1);
    vol_one.PartitionMaps.push_back(map2);

    int a = cin.ReadFileItem(0, 2, *lad, 50);
    return a;
}